---
title: "RAMP/COPING treatment paper core notebook"

author: "K L Purves"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: false
    number_sections: false
    highlight: monochrome
    theme: cerulean
    standalone: no
code_folding: show

html_notebook:
  theme: cerulean
toc: yes
---

This workbook runs code and shows results for the manuscript ***Access and uptake of mental health services during the COVID-19 pandemic: rates, barriers and usefulness***. 

# Project description

#### Research questions

1. What are the rates for treatment seeking for MH concerns at each time point (wave)
- rates over time

2. 

#### Details, discussion and questions

How do we show change over time in treatment seeking and receipt over time?
- are services overwhelmed?

#### Predictors

We select predictors that predict worse outcomes for common mental health problems in this sample [see GitHub for relevant paper here](https://github.com/klpurves/PANCHANGE_analysis/tree/forest_plots)


#### submission

Will submit to Psychological Medicine in first instance

#### variables that need creating

- did you seek treatment at any time

#### Variable categorisation

**treatment type:**
supported (requires contact) or self guided ()

Categorisation makes sense for resource allocation etc.

**reasons for seeking**
new or existing
crisis as a third (number dependent)

**barriers**
Systemic and client level

#### People who have helped along the way
Henry 
Laura
Molly

#### Figures

1. COVID figures, lockdown dates, histogram/density 
2. Bar plot 
3. Map of the UK showing rates of treatment seeking and receipt per area (prop sought treatment == size, proportion received == colour) probably district or rgion level?
4. Forest plots

** prevention figure: bars for each barrier type, coloured by whether systemic or client led

# set up 

Clear global environment
```{r Clear global environment}
remove(list = ls())
```

#### Call in set up scripts

```{r Setup, source files}
#source data directory: data_path
source("/Users/katherineyoung/OneDrive - King's College London/MQ_project/papers/RAMP-COPING_MH_treatment_paper/file_paths.R")
setwd(wd)
source("./scripts/palettes.R")
source("./scripts/libraries.R")

```


```{r Setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      comment=NA,
                      prompt=FALSE,
                      cache=FALSE,
                      root.dir=wd)

knitr::opts_chunk$set(fig.path="figures/")

options(bitmapType = 'quartz') # to render fonts better
```

Retrieve the current date to use it for file endings to not overwrite files when one exports files
```{r Recent date}
date = Sys.Date()
```

#### R functions

```{r call in function library functions}
# source all functions in the function library folder
files.sources = paste0("../FunctionLib/",list.files("../FunctionLib"))
sapply(files.sources, source)

```
# Colour palettes
Define colours for plotting this are the standard coping colours
```{r Colour palettes: COPING}
COPINGpalette2 <- c("#78D9C5",
                    "#F5BE5E")

COPINGpalette3 <- c("#78D9C5",
                    "#F5BE5E",
                    "#EEB6E9")

COPINGpalette4 <- c("#78D9C5",
                    "#F5BE5E",
                    "#EEB6E9",
                    "#DBDB73")

COPINGpalette5 <- c("#78D9C5",
                    "#F5BE5E",
                    "#EEB6E9",
                    "#DBDB73", 
                    "#FFED98")

COPINGpalette6 <- c("#78D9C5",
                    "#F5BE5E",
                    "#EEB6E9",
                    "#DBDB73",
                    "#FFED98",
                    "#BFD2EB")

COPINGpalette7 <- c("#78D9C5",
                    "#F5BE5E",
                    "#EEB6E9",
                    "#DBDB73", 
                    "#FFED98",
                    "#BFD2EB", 
                    "#808080")

COPINGpaletteGRAD <- c("#F5BE5E",
                       "#FFD284",
                       "#FFEED1",
                       "#B5B5B5",
                       "#DEFFF8",
                       "#94F6E1",
                       "#78D9C5")

COPINGNeuCenterpalette <- c("#78D9C5",
                            "#808080",
                            "#F5BE5E")

RAMPworseGRADpalette <- c("#78D9C5",
                          "#FFEED1",
                          "#F5BE5E",
                          "#FFB1B5")
GLADpalette = c("#efc00b", 
                "#b7dee8")  
```

Choose in this chunk which palette to use
04.07.2020 - Default to 2 colour COPING palette
```{r Choose colour palette}
palette = COPINGpalette2
```

# ggplot theme
Set up ggplot theme for the plots
```{r ggplot theme}
library(ggpubr)

theme_personal <-  theme(
    text = element_text(color = "black"),
    axis.title = element_text(color = "black"),
    axis.text = element_text(color = "black"),
    legend.background = element_blank(),
    legend.box.background = element_blank(),
    panel.background = element_blank(), 
    panel.grid.minor.x = element_blank(),
    panel.grid.major.x = element_line(
      colour = "gray",
      linetype = "dashed",
      size = 0.2
      ),
    axis.ticks = element_blank()
    )
```
# Data wrangling

#### Data import
RAMP
```{r read in data ramp}
treatRAMP <- readRDS(file = paste0(data_path, "/ramp_followupb/treatment_ramp_followupb.rds"))
demRAMP <- readRDS(file = paste0(data_path, "/ramp/dem_ramp.RDS"))

```

COPING
Note, external data reference is a hash-id for coping. So it is consistent across participants and matches, but is not linkable to GLAD ID
```{r read in data coping}

treatCOPE <- readRDS(file = paste0(data_path, "/coping_followupa_ongoing/treatment_coping_followupa_ongoing.rds"))

demCOPE.glad <- readRDS(file = paste0(data_path, "/coping_glad/dem_coping_glad.RDS"))
demCOPE.glad.baseline <- readRDS(file = paste0(data_path, "/glad/dem_glad.RDS"))

demCOPE.edgi <- readRDS(file = paste0(data_path, "/coping_edgi/dem_coping_edgi.RDS"))
demCOPE.edgi.baseline <- readRDS(file = paste0(data_path, "/edgi/demographics_edgi.RDS"))

demCOPE.nbr <- readRDS(file = paste0(data_path, "/coping_nbr/dem_coping_nbr.RDS"))
#demCOPE.nbr.baseline <- fread(paste0(data_path, "/nbr/NBR_hlq_dem_data_hash.csv"))
demCOPE.nbr.baseline <- fread(paste0(data_path, "/nbr_additional_info/coping_participants_export_20200730_hashed.csv"))


GLADpostcode <- fread(paste0(postpath,"/GLAD_COPING_postcodes.csv"))
EDGIpostcode <- fread(paste0(postpath,"/EDGI_COPING_postcodes.csv"))
NBRpostcode <- fread(paste0(postpath,"/NBR_postcodes_hash.csv"))

MHD.COPE.glad <- readRDS(file = paste0(data_path, "/coping_glad/mhd_coping_glad.rds"))
#MHD.COPE.edgi <- readRDS(file = paste0(cope_path, "/coping_edgi/mhd_coping_edgi.rds")) THIS IS IN THE DEMOGRAPHICS
MHD.COPE.nbr <- readRDS(file = paste0(data_path, "/coping_nbr/mhd_coping_nbr.rds"))
MHD.RAMP <- readRDS(file = paste0(data_path, "/ramp/mhd_ramp.rds"))

```


# Get age,gender & ethnicity for GLAD, EDGI & NBR

## GLAD
```{r age gender ethnicity GLAD}

GLADdemvars <- demCOPE.glad.baseline %>%
  select("externalDataReference","dem.which_gender_do_you_identify_with","dem.questions_based_ethnic_origin","dem.how_old_are_you_now.txt") %>%
  rename(ID=externalDataReference,
         Gender=dem.which_gender_do_you_identify_with,
         Ethnicity=dem.questions_based_ethnic_origin,
         Age.linear = dem.how_old_are_you_now.txt)

```


### make age categorical

Age cats:

-77: Seen but not answered
16-18
19-25
26-35
36-45
46-55
56-65
66-70
71-75
76-80
81-85
86-90
91-100
100+

```{r age categorical GLAD}

GLADdemvars <- GLADdemvars %>%
  mutate(AgeAll = case_when(Age.linear >=16 & Age.linear <= 18 ~ "16-18",
                            Age.linear >=19 & Age.linear <= 25 ~ "19-25",
                            Age.linear >=26 & Age.linear <= 35 ~ "26-35",
                            Age.linear >=36 & Age.linear <= 45 ~ "36-45",
                            Age.linear >=46 & Age.linear <= 55 ~ "46-55",
                            Age.linear >=56 & Age.linear <= 65 ~ "56-65",
                            Age.linear >=66 & Age.linear <= 70 ~ "66-70",
                            Age.linear >=71 & Age.linear <= 75 ~ "71-75",
                            Age.linear >=76 & Age.linear <= 80 ~ "76-80",
                            Age.linear >=81 & Age.linear <= 85 ~ "81-85",
                            Age.linear >=86 & Age.linear <= 90 ~ "86-90",
                            Age.linear >=91 & Age.linear <= 100 ~ "91-100",
                            Age.linear >=101 ~ "100+",
                            Age.linear ==-77 ~ "Did not respond"),
         Age80up = case_when(Age.linear >=16 & Age.linear <= 18 ~ "16-18",
                            Age.linear >=19 & Age.linear <= 25 ~ "19-25",
                            Age.linear >=26 & Age.linear <= 35 ~ "26-35",
                            Age.linear >=36 & Age.linear <= 45 ~ "36-45",
                            Age.linear >=46 & Age.linear <= 55 ~ "46-55",
                            Age.linear >=56 & Age.linear <= 65 ~ "56-65",
                            Age.linear >=66 & Age.linear <= 70 ~ "66-70",
                            Age.linear >=71 & Age.linear <= 75 ~ "71-75",
                            Age.linear >=76 & Age.linear <= 80 ~ "76-80",
                            Age.linear >=81  ~ "81+",
                            Age.linear ==-77 ~ "Did not respond"))

```


## EDGI
```{r age gender ethnicity EDGI}

EDGIdemvars <- demCOPE.edgi.baseline %>%
  select("externalDataReference","demographics.what_gender_do_you_identify_with","demographics.what_is_your_ethnic_origin","dem.how_old_are_you_now.txt") %>%
  rename(ID=externalDataReference,
         Gender=demographics.what_gender_do_you_identify_with,
         Ethnicity=demographics.what_is_your_ethnic_origin,
         Age.linear = dem.how_old_are_you_now.txt)

```


### make age categorical

Age cats:

-77: Seen but not answered
16-18
19-25
26-35
36-45
46-55
56-65
66-70
71-75
76-80
81-85
86-90
91-100
100+

```{r age categorical EDGI}

EDGIdemvars <- EDGIdemvars %>%
  mutate(AgeAll = case_when(Age.linear >=16 & Age.linear <= 18 ~ "16-18",
                            Age.linear >=19 & Age.linear <= 25 ~ "19-25",
                            Age.linear >=26 & Age.linear <= 35 ~ "26-35",
                            Age.linear >=36 & Age.linear <= 45 ~ "36-45",
                            Age.linear >=46 & Age.linear <= 55 ~ "46-55",
                            Age.linear >=56 & Age.linear <= 65 ~ "56-65",
                            Age.linear >=66 & Age.linear <= 70 ~ "66-70",
                            Age.linear >=71 & Age.linear <= 75 ~ "71-75",
                            Age.linear >=76 & Age.linear <= 80 ~ "76-80",
                            Age.linear >=81 & Age.linear <= 85 ~ "81-85",
                            Age.linear >=86 & Age.linear <= 90 ~ "86-90",
                            Age.linear >=91 & Age.linear <= 100 ~ "91-100",
                            Age.linear >=101 ~ "100+",
                            Age.linear ==-77 ~ "Did not respond"),
         Age80up = case_when(Age.linear >=16 & Age.linear <= 18 ~ "16-18",
                            Age.linear >=19 & Age.linear <= 25 ~ "19-25",
                            Age.linear >=26 & Age.linear <= 35 ~ "26-35",
                            Age.linear >=36 & Age.linear <= 45 ~ "36-45",
                            Age.linear >=46 & Age.linear <= 55 ~ "46-55",
                            Age.linear >=56 & Age.linear <= 65 ~ "56-65",
                            Age.linear >=66 & Age.linear <= 70 ~ "66-70",
                            Age.linear >=71 & Age.linear <= 75 ~ "71-75",
                            Age.linear >=76 & Age.linear <= 80 ~ "76-80",
                            Age.linear >=81  ~ "81+",
                            Age.linear ==-77 ~ "Did not respond"))

```


## NBR
```{r age gender ethnicity NBR}

NBRdemvars <- demCOPE.nbr.baseline %>%
  select("NBR ID","gender","ethnicity","age") %>%
  rename(ID=`NBR ID`,
         Gender=gender,
         Ethnicity=ethnicity,
         Age.linear = age)

```


### make age categorical

Age cats:

-77: Seen but not answered
16-18
19-25
26-35
36-45
46-55
56-65
66-70
71-75
76-80
81-85
86-90
91-100
100+

```{r age categorical NBR}

NBRdemvars <- NBRdemvars %>%
  mutate(AgeAll = case_when(Age.linear >=16 & Age.linear <= 18 ~ "16-18",
                            Age.linear >=19 & Age.linear <= 25 ~ "19-25",
                            Age.linear >=26 & Age.linear <= 35 ~ "26-35",
                            Age.linear >=36 & Age.linear <= 45 ~ "36-45",
                            Age.linear >=46 & Age.linear <= 55 ~ "46-55",
                            Age.linear >=56 & Age.linear <= 65 ~ "56-65",
                            Age.linear >=66 & Age.linear <= 70 ~ "66-70",
                            Age.linear >=71 & Age.linear <= 75 ~ "71-75",
                            Age.linear >=76 & Age.linear <= 80 ~ "76-80",
                            Age.linear >=81 & Age.linear <= 85 ~ "81-85",
                            Age.linear >=86 & Age.linear <= 90 ~ "86-90",
                            Age.linear >=91 & Age.linear <= 100 ~ "91-100",
                            Age.linear >=101 ~ "100+",
                            Age.linear ==-77 ~ "Did not respond"),
         Age80up = case_when(Age.linear >=16 & Age.linear <= 18 ~ "16-18",
                            Age.linear >=19 & Age.linear <= 25 ~ "19-25",
                            Age.linear >=26 & Age.linear <= 35 ~ "26-35",
                            Age.linear >=36 & Age.linear <= 45 ~ "36-45",
                            Age.linear >=46 & Age.linear <= 55 ~ "46-55",
                            Age.linear >=56 & Age.linear <= 65 ~ "56-65",
                            Age.linear >=66 & Age.linear <= 70 ~ "66-70",
                            Age.linear >=71 & Age.linear <= 75 ~ "71-75",
                            Age.linear >=76 & Age.linear <= 80 ~ "76-80",
                            Age.linear >=81  ~ "81+",
                            Age.linear ==-77 ~ "Did not respond"))

```


### Map ethnicity categories

-99: prefer not to say
-88: Dont know
-77: Seen but not answered

White
Mixed or multiple ethnicities
Asian or Asian british
Black or Black british
Arab
Other

```{r recategorise NBR ethnicity}

NBRdemvars <- NBRdemvars %>%
  mutate(Ethnicity = case_when(Ethnicity == "A (White - British)" |
                                 Ethnicity == "B (White - Irish)" |
                                 Ethnicity == "C (White - Other White)" ~ "White",
                               
                               Ethnicity == "D (Mixed - White and Black Caribbean)" |
                                 Ethnicity == "E (Mixed - White and Black African)" |
                                 Ethnicity == "F (Mixed - White and Asian)" |
                                 Ethnicity == "G (Mixed - Other Mixed)" ~ "Mixed or multiple ethnicities",
                               
                               Ethnicity == "H (Asian or Asian British - Indian)" |
                                 Ethnicity == "J (Asian or Asian British - Pakistani)" |
                                 Ethnicity == "K (Asian or Asian British - Bangladeshi)" |
                                 Ethnicity == "L (Asian or Asian British - Other Asian)" ~ "Asian or Asian British",
                               
                               Ethnicity == "M (Black or Black British - Caribbean)" |
                                 Ethnicity == "N (Black or Black British - African)" |
                                 Ethnicity == "P (Black or Black British - Other Black)" ~ "Black or Black British",
                               
                               Ethnicity == "R (Other Ethnic - Chinese)" |
                                 Ethnicity == "S (Other Ethnic - Other Ethnic)" ~ "Other",
                               
                               Ethnicity == "Z (Not Stated)" ~ "Seen but not answered"))
                                 
         

```

### clean gender other column from blank to labelled

```{r NBR clean gender}
NBRdemvars <- NBRdemvars %>%
  mutate(Gender = case_when(Gender == "Male" ~ "Male",
                            Gender == "Female" ~ "Female",
                            Gender == "" ~ "Did not respond"))
```


#### Create a wave columns in treatment data
Base this on dates of the follow ups drawn from qualtrics.

RAMP
5 waves

1 - May 2020
2 - June 2020
3 - July 2020 (start date actually the last day of June)
4 - September 2020
5 - November 2020

```{r identify wave dates ramp}
setwd(wd)
source("./scripts/RAMPwaves.R")
```

COPING
```{r identify wave dates coping}
setwd(wd)
source("./scripts/COPINGwaves.R")
```
#### drop data before data collection started

Drop Any data collected earleir than June (our first instance of the questionnaire)

```{r drop May dat}

treatRAMP <- treatRAMP %>%
  filter(startDate > as.POSIXct("2020-06-01"))

```


#### select only relevant demographics

```{r demographic select list}
keepcols.cope <- c("externalDataReference","dem.which_gender_do_you_identify_with")
cols.cope <- c("ID","Gender")
keepcols.nbr <- c("subjectid")
cols.nbr <- c("ID")
keepcols.ramp <- c("Login ID","dem2.how_old_are_you","dem2.which_gender_do_you_identify_with","dem2.where_in_the_uk_do_you_live.txt","dem2.what_is_your_ethnic_origin")
cols.ramp <- c("ID","Age","Gender","Postcode","Ethnicity")

names.postcode <- c("ID","Postcode")

```


```{r demographic select}
dem.cope.glad <- demCOPE.glad[names(demCOPE.glad) %in% keepcols.cope]
dem.cope.edgi <- demCOPE.edgi[names(demCOPE.edgi) %in% keepcols.cope]
dem.cope.nbr <- demCOPE.nbr[names(demCOPE.nbr) %in% keepcols.nbr]
dem.ramp <- demRAMP[names(demRAMP) %in% keepcols.ramp]

names(dem.cope.glad) <- cols.cope
names(dem.cope.edgi) <- cols.cope
names(dem.cope.nbr) <- cols.nbr
names(dem.ramp) <- cols.ramp


names(GLADpostcode) <- names.postcode
names(EDGIpostcode) <- names.postcode
names(NBRpostcode) <- names.postcode


```
Clean postcode to keep only outcode for COPING

```{r clean COPING postcodes}

setwd(wd)
source("./scripts/clean_COPING_postcode_data.R")

```

Add postcode to COPING

```{r add postcode to coping}

dem.cope.glad <- left_join(dem.cope.glad,GLADpostcode)
dem.cope.edgi <- left_join(dem.cope.edgi,EDGIpostcode)
dem.cope.nbr <- left_join(dem.cope.nbr,NBRpostcode)

```

#### Add extra demographic variables

```{r merge glad/edgi/nbr baseline demographics to their other demographics}

dem.cope.glad <- left_join(dem.cope.glad, GLADdemvars)
dem.cope.edgi <- left_join(dem.cope.edgi, EDGIdemvars)
dem.cope.nbr <- left_join(dem.cope.nbr, NBRdemvars)

```


#### add sample columns 

```{r add sample col}

dem.cope.glad$Sample <-  "COPING"
dem.cope.glad$SampleCOPE <-  "GLAD"
dem.cope.edgi$Sample <- "COPING"
dem.cope.edgi$SampleCOPE <- "EDGI"
dem.cope.nbr$Sample <- "COPING"
dem.cope.nbr$SampleCOPE <- "NBR"
dem.ramp$Sample <- "RAMP"

treatRAMP$Sample <- "RAMP"
treatCOPE$Sample <- "COPING"

```



# Demographics cleaning

## clean age (RAMP)

Age cats:

-77: Seen but not answered
1: 16-18
2: 19-25
3: 26-35
4: 36-45
5: 46-55
6: 56-65
7: 66-70
8: 71-75
9: 76-80
10: 81-85
11: 86-90
12: 91-100
13: 100+

```{r make and label age factors}

dem.ramp <- dem.ramp %>%
  mutate_at(vars(Age),
            list(factor))  %>%
  mutate(AgeAll = fct_recode(Age, 
                                "16-18"="1",
                                "19-25"="2",
                                "26-35"="3",
                                "36-45"="4",
                                "46-55"="5",
                                "56-65"="6",
                                "66-70"="7",
                                "71-75"="8",
                                "76-80"="9",
                                "81-85"="10",
                                "86-90"="11",
                                "91-100"="12",
                                "100+"="13",
                                "Did not respond"="-77"
                                ),
         Age80up = fct_recode(Age, 
                                "16-18"="1",
                                "19-25"="2",
                                "26-35"="3",
                                "36-45"="4",
                                "46-55"="5",
                                "56-65"="6",
                                "66-70"="7",
                                "71-75"="8",
                                "76-80"="9",
                                "81+"="10",
                                "81+"="11",
                                "81+"="12",
                                "81+"="13",
                                "Did not respond"="-77"
                                ))

```

## Join RAMP, GLAD and EDGI

```{r join ramp, edgi and glad dems}

dem <- merge(dem.ramp,dem.cope.glad, all=TRUE)
dem <- merge(dem,dem.cope.edgi, all=TRUE)

```

## clean ethnicity
Ethnicity:

-99: prefer not to say
-88: Dont know
-77: Seen but not answered
1: White
2: Mixed or multiple ethnicities
3: Asian or Asian british
4: Black or Black british
5: Arab
6 :Other

```{r make and label ethnicity factors}

dem <- dem %>%
  mutate_at(vars(Ethnicity),
            list(factor))  %>%
  mutate(Ethnicity = fct_recode(Ethnicity, 
                                "White"="1",
                                "Mixed or multiple ethnicities"="2",
                                "Asian or Asian British"="3",
                                "Black or Black British"="4",
                                "Arab"="5",
                                "Other"="6",
                                "Prefer not to say"="-99",
                                "Don't know"="-88",
                                "Did not respond"="-77"
                                ))

```



## clean gender
Gender cats:

-99: prefer not to say
-88: Dont know
-77: Seen but not answered
0: Male
1: female
3: Non-binary
4: prefer to self define

```{r make and label gender factors}

dem <- dem %>%
  mutate_at(vars(Gender),
            list(factor))  %>%
  mutate(Gender = fct_recode(Gender, 
                                "Male"="0",
                                "Female"="1",
                                "Non-binary"="2",
                                "Prefer to self define"="3",
                                "Prefer not to say"="-99",
                                "Don't know"="-88",
                                "Did not respond"="-77"
                                ))

```

#### merge demographics with NBR 

```{r demographics merge}

dem <- merge(dem,dem.cope.nbr,all=TRUE)

```


#### get gender columns to add to treatment

```{r gender from demo}
demgen <- subset(dem,select = c("ID","Gender","Sample"))
```


# mental health diagnosis cleaning


rename id columns so they all match

```{r rename mhd id vars}

MHD.RAMP <- MHD.RAMP %>%
  rename(ID="Login ID")

MHD.COPE.nbr <- MHD.COPE.nbr %>%
  rename(ID="subjectid")

MHD.COPE.glad <- MHD.COPE.glad %>%
  rename(ID="externalDataReference")



```

## Identify subset of diagnoses we have for all datasets.

This includes the full range of MH questions we asked in RAMP

```{r rename ramp var names to match COPING}

names(MHD.RAMP) <- sub("mhq","mhd",names(MHD.RAMP))
names(MHD.RAMP) <- sub(".1","",names(MHD.RAMP))
names(MHD.COPE.glad) <- sub(".1","",names(MHD.COPE.glad))
names(MHD.COPE.nbr) <- sub(".1","",names(MHD.COPE.nbr))

```

```{r find column columns}

common_col_names <- intersect(names(MHD.RAMP),names(MHD.COPE.glad))
common_col_names <- intersect(common_col_names,names(MHD.COPE.nbr))

# remove the second personality option which says what specific personality disorder is diagnosed.
common_col_names <- common_col_names[common_col_names != "mhd.personality_disorder_diagnosed"]

```

Rename EDGI colums to make sure we can compare

```{r rename edgi mental health diagnosis names}

MHD.COPE.edgi <- demCOPE.edgi.baseline
names(MHD.COPE.edgi) <- sub("demographics","mhd",names(MHD.COPE.edgi))
names(MHD.COPE.edgi) <- sub(".1","",names(MHD.COPE.edgi))
names(MHD.COPE.edgi) <- sub("externalDataReference","ID",names(MHD.COPE.edgi))


```

find intersect with edgi columns

```{r intersect mhd with edgi}
common_col_names_edg <- intersect(common_col_names,names(MHD.COPE.edgi))

```
this shows that the only ones not common are eating disorder categories. makes sense as EDGI is ascertained on the basis of having one. So if we collapse across eating disorders we can assume that all edgi fall into this. Will add EDGI last to achieve this. 


### select the appropriate columns and merge samples


```{r select columns}

MH.RAMP <- MHD.RAMP %>%
  select(all_of(common_col_names)) %>%
  mutate(Sample = "RAMP")

MH.GLAD <- MHD.COPE.glad %>%
  select(all_of(common_col_names)) %>%
  mutate(Sample = "COPING",
         SampleCOPE = "GLAD")

MH.NBR <- MHD.COPE.nbr %>%
  select(all_of(common_col_names)) %>%
  mutate(Sample = "COPING",
         SampleCOPE = "NBR")

```


```{r merge the three datasets}

MH <- merge(MH.RAMP,MH.GLAD,all = "TRUE")
MH <- merge(MH,MH.NBR,all = "TRUE")

```


```{r collapse all eating disorders together and drop the others}

MH <- MH %>%
  mutate(mhd.eating_disorder = case_when("mhd.anorexia_nervosa" == 1 |
                                           "mhd.atypical_anorexia_nervosa" == 1|
                                           "mhd.bulimia_nervosa" == 1 ~1)) %>%
  select(-c(mhd.anorexia_nervosa,mhd.atypical_anorexia_nervosa,mhd.bulimia_nervosa))

```

EDGI all have eating disorders (ascertained for this)
```{r creat eating disorder category for EDGI}

MHD.COPE.edgi$mhd.eating_disorder <- 1

```

adjust common col list for EDGI

```{r adjust common cols for edgi}

common_col_names <- common_col_names[common_col_names != "mhd.anorexia_nervosa"]
common_col_names <- common_col_names[common_col_names != "mhd.atypical_anorexia_nervosa"]
common_col_names <- common_col_names[common_col_names !="mhd.bulimia_nervosa"]


common_col_names <- append(common_col_names,"mhd.eating_disorder")

```

```{r select columns for EDGI}

MH.EDGI <- MHD.COPE.edgi %>%
  select(all_of(common_col_names)) %>%
  mutate(Sample = "COPING",
         SampleCOPE = "EDGI")

```

Merge EDGI onto rest

```{r merge edgi MH to others}

MH <- MH <- merge(MH,MH.EDGI,all = "TRUE")

```

drop start and end date (don't need it as we just need a single point per person)

```{r drop start and end date}

MH <- MH %>%
  select(-c(startDate,endDate)) 

```




# Rename the treatment variables and drop irrelevant ones

used the [data dictionary](https://docs.google.com/spreadsheets/d/1Vp028XLxbcXeOdjeuI-3y-kVenKWDR4hW9iJ1tHpttI/edit#gid=1527211037) to identify the relevant items and rename them

```{r rename COPE & RAMP datasets and select variables}
setwd(wd)
source("./scripts/renameRAMPtreatment.R")

treatRAMP.fin <- treatRAMP.renamed[names(treatRAMP.renamed) %in% treatnames]
treatCOPE.fin <- treatCOPE.renamed[names(treatCOPE.renamed) %in% treatnames]

```
#### merge RAMP and COPING treatment data

Use rbind to add COPING to RAMP

```{r merge coping and ramp treatment data}

treat_dat <- rbind(treatRAMP.fin,treatCOPE.fin)
  
```

#### order wave variable

```{r reorder wave factor}

treat_dat$wave <- factor(treat_dat$wave,
                         levels = c("May 2020","June 2020", "July 2020","August 2020","September 2020","October 2020","November 2020","December 2020","January 2021"))

```

#### Drop accidental duplicate IDs

these are IDS that were allocated twice by qualtrics. Technical errors. Will drop all instances (we lose 80 IDs doing this)
```{r id  duplicates}

DupIDdat <- treat_dat %>%
  pivot_wider(id_cols = ID,
              names_from = wave,
              values_from = soughthelp_for_self,
              values_fn = length)

dupids <- DupIDdat$ID[(DupIDdat$`June 2020` > 1 | DupIDdat$`July 2020` > 1 |
                         DupIDdat$`August 2020` > 1 | DupIDdat$`September 2020` > 1 |
                         DupIDdat$`October 2020` > 1 | DupIDdat$`November 2020` > 1 |
                         DupIDdat$`December 2020` > 1 | DupIDdat$`January 2021` > 1)]

dupids <- unique(dupids)

```

Now drop from our treatment data

```{r drop dups from treatment}
treat_dat <- treat_dat[(treat_dat$ID %!in% dupids),]
```

#### make seen but not responded NA 

```{r make -77 in treatment seeking NA}

treat_dat$soughthelp_for_self <- ifelse(treat_dat$soughthelp_for_self == -77,NA,treat_dat$soughthelp_for_self)

```

#### Create summary variables for treatment
Grouping variables to make sensible categories for comparing different aspects of treatment seeking


##### Sought help for new or pre-existing MH disorder 

Categorise reasons for help seeking into whether it was for a pre-existing, newly emerging MH disorder or a crisis

```{r dummy reason for help seek variable}

treat_dat <- treat_dat %>%
  mutate(ReasonSeek = case_when(reasonhelp_new_mh == 1 ~ "Newly emerging symptoms",
                                reasonhelp_cont_mh == 1 | reasonhelp_worsen_mh == 1 | reasonhelp_repeat_prescription == 1 |
                                 reasonhelp_change_med == 1 | reasonhelp_alt_support == 1 ~ "Existing mental health",
                                reasonhelp_mh_crisis == 1 ~ "Mental health crisis",
                               reasonhelp_new_med == 1 ~ "Seeking new treatment"))

```


##### Type of treatment (supported / self guided)

Categorise places where treatment was sought into supported or self-guided


make Prefer not to say (-77) NA

```{r na for PNS treatment type sought}
treat_dat[grep("wherehelp",names(treat_dat))] <-apply(treat_dat[grep("wherehelp",names(treat_dat))],2,function(x) ifelse(x == -77,NA, x))
```

create a variable that will say if they sought supported or self guided for each support instance
```{r dummy type of treatment sought}

treat_dat <- treat_dat %>%
  mutate(TypeSought.Supported.Any  = case_when(wherehelp_sought_emergency_mh == 1 ~ "Sought Supported",
                               wherehelp_sought_existing_mh_team == 1 ~ "Sought Supported",
                                wherehelp_sought_online_talk_therapy == 1 ~ "Sought Supported",
                                wherehelp_sought_gp == 1 ~ "Sought Supported",
                                wherehelp_sought_nonnhs_phone == 1 ~ "Sought Supported",
                                wherehelp_sought_nhs_111 == 1 ~ "Sought Supported", 
                               TRUE ~ "Did not seek supported treatment"),
         TypeSought.SelfGuide.Any = case_when(
                                wherehelp_sought_gov_website == 1 ~ "Sought Self-guided",
                                wherehelp_sought_selfguide_online == 1 ~ "Sought Self-guided",
                                wherehelp_sought_nongov_website == 1 ~ "Sought Self-guided",
                                wherehelp_sought_struc_therapy == 1 ~ "Sought Self-guided",
                                TRUE ~ "Did not seek self-guided treatment")) %>%
  
  mutate(AnySought = case_when(TypeSought.Supported.Any  == "Sought Supported" ~ 1,
                                  TypeSought.SelfGuide.Any  == "Sought Self-guided" ~ 1,
                                 TRUE ~ 0))
```

creat variable counting number of self guided or supported treatment types sought per wave per person

```{r type sought counts}

supportcols <- c("wherehelp_sought_emergency_mh","wherehelp_sought_online_talk_therapy",
                 "wherehelp_sought_gp","wherehelp_sought_existing_mh_team",
                " wherehelp_received_nonnhs_phone","wherehelp_sought_nhs_111")

selfcols <- c("wherehelp_sought_gov_website","wherehelp_received_selfguide_online",
                 "wherehelp_sought_nongov_website","wherehelp_sought_struc_therapy")


treat_dat$TypeSought.Supported.total <- rowSums(treat_dat[names(treat_dat) %in% supportcols],na.rm = T)
treat_dat$TypeSought.SelfGuided.total <- rowSums(treat_dat[names(treat_dat) %in% selfcols],na.rm = T)

```

##### received treatment if sought 

identify if treatment was received when sought according to category
```{r dummy type of treatment received}

treat_dat <- treat_dat %>%
  mutate(TypeReceived.Supported.Any  = case_when(wherehelp_received_emergency_mh == 1 ~ "Received Supported",
                               wherehelp_received_existing_mh_team == 1 ~ "Received Supported",
                                wherehelp_received_online_talk_therapy == 1 ~ "Received Supported",
                                wherehelp_received_gp == 1 ~ "Received Supported",
                                wherehelp_received_nonnhs_phone == 1 ~ "Received Supported",
                                wherehelp_received_nhs_111 == 1 ~ "Received Supported", 
                               TRUE ~ "Did not receive supported treatment"),
         TypeReceived.SelfGuide.Any = case_when(
                                wherehelp_received_gov_website == 1 ~ "Received Self-guided",
                                wherehelp_received_selfguide_online == 1 ~ "Received Self-guided",
                                wherehelp_received_nongov_website == 1 ~ "Received Self-guided",
                                wherehelp_received_struc_therapy == 1 ~ "Received Self-guided",
                                TRUE ~ "Did not receive self-guided treatment")) %>%
  
  mutate(AnyReceived = case_when(TypeReceived.Supported.Any  == "Received Supported" ~ 1,
                                  TypeReceived.SelfGuide.Any  == "Received Self-guided" ~ 1,
                                 TRUE ~ 0))
```

```{r dummy treatment not received if sought}

treat_dat  <- treat_dat %>%
  mutate(AnyNoReceipt = case_when(AnyReceived == 0 ~1,
                                  TRUE ~ 0))

```

##### number of agencies from which treatment was received, if sought

```{r type received counts}

supportcols <- c("wherehelp_received_emergency_mh","wherehelp_received_online_talk_therapy",
                 "wherehelp_received_gp","wherehelp_received_existing_mh_team",
                " wherehelp_received_nonnhs_phone","wherehelp_received_nhs_111")

selfcols <- c("wherehelp_received_gov_website","wherehelp_received_selfguide_online",
                 "wherehelp_received_nongov_website","wherehelp_received_struc_therapy")


treat_dat$TypeReceived.Supported.total <- rowSums(treat_dat[names(treat_dat) %in% supportcols],na.rm = T)
treat_dat$TypeReceived.SelfGuided.total <- rowSums(treat_dat[names(treat_dat) %in% selfcols],na.rm = T)

```

##### Sought treatment at any time (How many times, how many total responses)

Create a dataset and column that identifies how many times someone sought help, how many times they responded, and if they ever sought help

Making a new dataset where the count by ID is tracked
```{r treatment seek in any wave count}

treat_dat_byID <- treat_dat %>%
  group_by(ID) %>%
  tally(soughthelp_for_self)

treat_dat_byIDSamp <- treat_dat %>%
  group_by(ID,Sample) %>%
  tally(soughthelp_for_self)

```
##### Reason not sought
```{r reason not sought}

reason_not_sought <- tibble(reason = c("Feel fine","Feel better","Not bad enough","Don't think help available","Bad past experience","Didn't know where to find","Too busy","Want to but haven't","Other"),category = c("Mild or no current symptoms","Mild or no current symptoms","Mild or no current symptoms","Systemic","Systemic","Systemic","Client","Client","Other"), n = 1:9)

reason_not_sought[1,3] <- sum(treat_dat$reasonNohelp_feel_fine==1,na.rm=TRUE)
reason_not_sought[2,3] <- sum(treat_dat$reasonNohelp_I_feel_better==1,na.rm=TRUE)
reason_not_sought[3,3] <- sum(treat_dat$reasonNohelp_I_dont_think_I_feel_bad_enough==1,na.rm=TRUE)
reason_not_sought[4,3] <- sum(treat_dat$reasonNohelp_I_want_help_dont_think_its_available==1,na.rm=TRUE)
reason_not_sought[5,3] <- sum(treat_dat$reasonNohelp_Bad_experiences_in_past==1,na.rm=TRUE)
reason_not_sought[6,3] <- sum(treat_dat$reasonNohelp_I_didnt_know_where_to_find==1,na.rm=TRUE)
reason_not_sought[7,3] <- sum(treat_dat$reasonNohelp_Too_busy==1,na.rm=TRUE)
reason_not_sought[8,3] <- sum(treat_dat$reasonNohelp_I_want_to_but_havent==1,na.rm=TRUE)
reason_not_sought[9,3] <- sum(treat_dat$reasonNohelp_other==1,na.rm=TRUE)

```

```{r treatment seek in any wave}

treat_dat_byID$AnySeek <- ifelse(treat_dat_byID$n > 0,"Sought help at least once", "Never sought help")
treat_dat_byIDSamp$AnySeek <- ifelse(treat_dat_byIDSamp$n > 0,"Sought help at least once", "Never sought help")

```

##### Client level vs systemic barriers
identify if treatment was received when sought according to category

```{r run script to relabel and clean treatment hep and barrier factors}
setwd(wd)
## factorise and label barrier and helpfulness 
source("./scripts/relabel_barriers_help_factors.R")

```

Identify whether barriers are systemic or client-level
```{r dummy type of barriers}
## systemic
treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Could not get an appointment","Systemic",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Waiting list was too long","Systemic",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Was assessed and was unable to be offered support","Systemic",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Support option was unavailable when tried to access it","Systemic",x))

## client level
treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "None of the support options were relevant","Client-level",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Didn't feel well enough to engage","Client-level",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Was too busy to engage","Client-level",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Felt better","Client-level",x))

```

#### group agencies for help prevention into client-led or supported
creates PreventHelp_Supported and PreventHelp_SelfGuided columns

```{r group barrier agencies into client led or supported}
setwd(wd)
source("./scripts/Barriers_column_creation.R")
```

### helpfulness

#### Relabel factors

```{r relabel helpfullness factors}

setwd(wd)
source("./scripts/Relabel_helpful_factors.R")

```
#### group agencies for helpfulness into client led or supported.
Assess helpfulness for both type seperately depending on helpfulness by agency sought

```{r group helpfullness agencies into client led or supported}
setwd(wd)
source("./scripts/Helpfulness_column_creation.R")
```

# Analyses

## Descriptives


### Demographics

Age, ethnicity and gender for those who have responded to at least 1 wave of the treatment survey, dropping duplicates as per treat_dt step


```{r drop all IDS that are not included in our treatment data from the demographics data}

dem <- dem %>%
  filter(dem$ID %in% treat_dat_byID$ID) %>%
  distinct(.)

```


**At the moment this is only keeping 15656 people, when we have 27926 distinct IDs in the treatment data. It is possible this is due to not having demographic info for the NBR sample, but need to check these numbers once NBR is added and look into it if these are still out**


#### check numbers

##### Ethnicity

```{r ethnicity table}

dem %>%
  freq(Ethnicity)

```
By sample
```{r ethnicity by Sample table}

dem %>%
  group_by(Sample) %>%
  freq(Ethnicity)


```
##### Gender

```{r Gender table}

dem %>%
  freq(Gender)

```
By sample
```{r Gender by Sample table}


dem %>%
  group_by(Sample) %>%
  freq(Gender)
```

##### Age (all brackets)


```{r Age table}
dem %>%
  freq(AgeAll)

```

By sample
```{r Age by Sample table}

dem %>%
  group_by(Sample) %>%
  freq(AgeAll)

```


##### Age (81+ collapses)


```{r Age 81+ table}

dem %>%
  freq(Age80up)

```

By sample
```{r Age 81+  by Sample table}

dem %>%
  group_by(Sample) %>%
  freq(Age80up)

```

### Mental health diagnoses

Clean so we match treatment data and dont have duplicates
```{r drop all IDS that are not included in our treatment data from the MHD data}

MH <- MH %>%
  filter(MH$ID %in% treat_dat_byID
         
         $ID) %>%
  distinct(.)

```

List of diagnosis columns

```{r list diagnoses cols}

dia_cols <- c("mhd.depression", "mhd.mania_hypomania_bipolar_or_manicdepression", 
"mhd.anxiety_nerves_or_generalised_anxiety_disorder", "mhd.social_anxiety_or_social_phobia", 
"mhd.agoraphobia", "mhd.panic_disorder", "mhd.panic_attacks", 
"mhd.obsessivecompulsive_disorder_ocd", "mhd.dont_know", "mhd.prefer_not_to_answer", 
"mhd.schizophrenia", "mhd.psychosis_type_psychotic_illness", 
"mhd.personality_disorder", "mhd.attention_deficit_hyperactivity_disorder","mhd.eating_disorder")
  
```

#### everyone

frequencies for all diagnoses
```{r freq tables for diagnoses}

for (i in dia_cols){
  print(freq(MH[i]))
}

```


#### By sample
frequencies for all diagnoses
```{r freq tables for diagnoses by sample}

for (i in dia_cols){
  print(i)
    print(ctable(MH[,i],MH$Sample))
}

```

## treat dat
### Response rates per wave

```{r response rates per wave}

treat_dat_count <- treat_dat %>%
  group_by(wave) %>%
  count()

treat_dat_count
```
```{r plot response rates per wave}

treat_dat_count_plot <- treat_dat_count[-c(9), ]  %>%
  ggplot(mapping = aes(
    x=wave,
    y=n)
    ) +
    geom_bar(aes(),
      stat="identity",
     position = position_dodge2(preserve = "single")
    ) +
  labs(
    x = "Time point",
    y = "Number of participants") +
  theme_personal +
  scale_fill_manual(
    values = COPINGpalette4
  ) +
  coord_flip()
treat_dat_count_plot


```

By sample
```{r response rates per wave by sample}

treat_dat_count_by_sample <- treat_dat %>%
  group_by(wave,Sample) %>%
  count()
```
###*Plot sample size*
```{r plot response rates per wave per sample}
treat_dat_count_by_sample[-c(16),]
treat_dat_count_by_sample_plot <- treat_dat_count_by_sample[-c(16),]  %>%
  ggplot(mapping = aes(
    x=wave,
    y=n)
    ) +
    geom_bar(aes(fill = Sample),
      stat="identity",
     position = position_dodge2(preserve = "single")
    ) +
  labs(
    x = "Time point",
    y = "Number of participants") +
  theme_personal +
  scale_fill_manual(
    values = COPINGpalette4
  ) +
  coord_flip()
treat_dat_count_by_sample_plot


```

### Frequency of treatment seeking per wave

```{r treatment seeking freq by wave}

treat_dat_seek_count <- treat_dat %>%
  group_by(wave) %>%
  count(soughthelp_for_self)
  
treat_dat_seek_count <- pivot_wider(treat_dat_seek_count, names_from = soughthelp_for_self, values_from = n) 

treat_dat_seek_count$total_responders <- treat_dat_seek_count$`0` + treat_dat_seek_count$`1`

treat_dat_seek_count$prop_responders <- treat_dat_seek_count$`1` / treat_dat_seek_count$total_responders*100

treat_dat_seek_count

```

```{r plot treatment seeking rates per wave}


treat_dat_seek_count_plot <- treat_dat_seek_count[-c(1,9),]  %>%
  ggplot(mapping = aes(wave, prop_responders,fill = "placeholder")
    ) +
    geom_bar(aes(),
      stat="identity",
     position = position_dodge2(preserve = "single")
    ) +
  labs(title = "Treatment seeking", x = "Time point",  y = "Frequency of seeking treatment (%)") +
  theme_personal +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "none") + 
  scale_fill_manual(
    values = COPINGpalette4
  ) 
treat_dat_seek_count_plot


```

###*Plot treatment gap*
```{r plot treatment not received if sought}

treat_dat_gap_count <- treat_dat %>%
  group_by(wave) %>%
  count(AnyReceived)
  
treat_dat_gap_count <- pivot_wider(treat_dat_gap_count, names_from = AnyReceived, values_from = n) 

treat_dat_gap_count$total_sought <- treat_dat_seek_count$`1`

treat_dat_gap_count$prop_received <- treat_dat_gap_count$`1` / treat_dat_gap_count$total_sought*100
treat_dat_gap_count$prop_gap <- 100-treat_dat_gap_count$prop_received

combined_seek_gap_plot <- treat_dat_gap_count[-c(1,9),c(1,5:6)]
combined_seek_gap_plot$prop_seek <- treat_dat_seek_count$prop_responders[-c(1,9)]
combined_seek_gap_plot$`Treatment received` <- (combined_seek_gap_plot$prop_seek/100*combined_seek_gap_plot$prop_received/100)*100
combined_seek_gap_plot$`Treatment not received` <- (combined_seek_gap_plot$prop_seek/100*combined_seek_gap_plot$prop_gap/100)*100
  
#summary values per wave
combined_seek_gap_plot[,c(1,5:6)]

long_prop_receipt <- combined_seek_gap_plot[,c(1,5:6)] %>%
  pivot_longer(!wave, names_to = "received",values_to = "percent")

long_prop_receipt$received <- as.factor(long_prop_receipt$received)
  
treat_dat_received_plot <- long_prop_receipt %>%
  ggplot(mapping = aes(wave, percent, fill = received)
    ) +
    geom_bar(aes(),
      stat="identity",
     position = "stack"
    ) +
  labs(title = "Frequencies of treatment seeking and receipt", x = "Time point",  y = "Proportion of sample (%)") +
  theme_personal +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.title = element_blank()) +
  scale_fill_manual(
    values = rev(COPINGpalette2)
  ) 
treat_dat_received_plot


```


By sample

```{r treatment seeking freq by wave by sample}

txseek_by_sample <- treat_dat %>%
  group_by(wave,Sample) %>%
  freq(soughthelp_for_self)

```
### Reason for seeking treatment by wave

```{r reason seek by wave}

txseek_by_wave <- treat_dat %>%
  group_by(wave) %>%
  freq(ReasonSeek)

```

```{r reason seek by wave count}

 reasons_seek_count <- treat_dat %>%
  group_by(wave) %>%
  count(ReasonSeek)
  
reasons_seek_count <- pivot_wider(reasons_seek_count, names_from = ReasonSeek, values_from = n) 

prop_seek_count <- reasons_seek_count

prop_seek_count$total_responders <- prop_seek_count$`Existing mental health` + prop_seek_count$`Mental health crisis` + prop_seek_count$`Newly emerging symptoms` + prop_seek_count$`Seeking new treatment`

prop_seek_count$`Existing mental health concern` <- prop_seek_count$`Existing mental health` / prop_seek_count$total_responders*100
prop_seek_count$`Existing mental health` <- NULL

prop_seek_count$`Mental health crisis` <- prop_seek_count$`Mental health crisis` / prop_seek_count$total_responders*100

prop_seek_count$`Newly emerging symptoms` <- prop_seek_count$`Newly emerging symptoms` / prop_seek_count$total_responders*100

prop_seek_count$`Seeking new treatment` <- prop_seek_count$`Seeking new treatment` / prop_seek_count$total_responders*100

prop_seek_count
```
###*Plot reason seek*
```{r reason seek by wave plot}

prop_reasons <- prop_seek_count[-c(1,9),-c(2,6)] 

long_prop_reasons <-  prop_reasons %>%
pivot_longer(!wave, names_to = "ReasonSeek", values_to = "n")

long_prop_reasons$ReasonSeek <- as.factor(long_prop_reasons$ReasonSeek)

long_prop_reasons$ReasonSeek <- factor(long_prop_reasons$ReasonSeek, levels=c("Mental health crisis","Seeking new treatment","Newly emerging symptoms","Existing mental health concern"), ordered=TRUE)

treat_dat_seek_count_plot <- long_prop_reasons %>%
  ggplot(mapping = aes(wave, n, fill = ReasonSeek)
    ) +
    geom_bar(aes(),
      stat="identity",
     position = "stack"
    ) +
  labs(title = "Reasons for seeking treatment", x = "Time point",  y = "Reason for seeking treatment (%)") +
  theme_personal +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.title = element_blank()) +
  scale_fill_manual(
    values = rev(COPINGpalette4)
  ) 
prop_reasons
treat_dat_seek_count_plot
```
By sample
```{r reason seek by wave by sample}

reason_seek_by_wave_sample <- treat_dat %>%
  group_by(wave,Sample) %>%
  freq(ReasonSeek)

```
###*Plot reason not seek*
```{r reason not seek plot}
total_reasons <- sum(reason_not_sought$n)
reason_not_sought$percent <- reason_not_sought$n/total_reasons*100

summary_reason_not_sought <- reason_not_sought %>%
  group_by(category) %>%
  summarise(total = sum(n))

summary_reason_not_sought$percent <- summary_reason_not_sought$total/total_reasons*100

reason_not_sought
summary_reason_not_sought

reorder_summary <- summary_reason_not_sought %>%
  arrange(match(category, c("Other","Client","Systemic","Mild or no current symptoms"),desc(percent)))

reorder_summary$category <- factor(reorder_summary$category, levels=c("Other","Client","Systemic","Mild or no current symptoms"), ordered=TRUE)

pie <- reorder_summary %>%
  ggplot(aes(x="", y=percent, fill=category)) +
  geom_bar(width = 1, stat = "identity") +
  scale_fill_manual(values = rev(COPINGpalette4)) +
  coord_polar("y",start=0) +
  theme_void() +
  labs(fill = "Category of reason") +
  geom_text(aes(y = c((round(percent,digits=1))),
                x = c(1.2,1.2,1.2,1.2),
                label=paste0(round((percent),0),"%")),
            size=5,
            position = position_stack(vjust = 0.5)
  )
pie
```



### Frequency of treatment receipt by type and wave (any instances of treatment, not total instances)

Seeking ANY instances of this type of treatment (i.e., if they sought supported help from 3 sources in a  wave, it will just register once)
BUT they might ALSO have sought help from both routes (i.e., if they sought help from a supported and self guided source, they will register in each of these categories. So we might expect to have more people in the supported + self guided categories per wave than we do who sought help for themselves above)


**Supported**
```{r treatment sought by wave supported any}
tx_supported_by_wave <- treat_dat %>%
  group_by(wave) %>%
  count(TypeSought.Supported.Any)

supported_count <- pivot_wider(tx_supported_by_wave, names_from = TypeSought.Supported.Any, values_from = n) 

supported_count <- supported_count[-c(1,9),]
supported_count
```
By sample
```{r treatment sought by wave supported any by sample}
tx_seek_by_wave_supported <- treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeSought.Supported.Any)

```

**Self guided**
```{r treatment sought by wave self guided any}
tx_selfguided_by_wave <- treat_dat %>%
  group_by(wave) %>%
  count(TypeSought.SelfGuide.Any)

selfguided_count <- pivot_wider(tx_selfguided_by_wave, names_from = TypeSought.SelfGuide.Any, values_from = n) 

selfguided_count <- selfguided_count[-c(1,9),]
selfguided_count

```

By sample
```{r treatment sought by wave self guided any by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeSought.SelfGuide.Any)

```

### Frequency of treatment seeking overall
Number of people who sought treatment at any point during the pandemic
```{r check  overall treatment seeking}

treat_dat_byID %>%
  freq(AnySeek)

```


By sample
```{r check  overall treatment seeking by sample}

treat_dat_byIDSamp %>%
  group_by(Sample) %>%
  freq(AnySeek)

```

### Count table of treatment seeking across all waves
Number of times people sought treatment at any point during the pandemic (so, 138 people sought help 4 times)
```{r check number of overall treatment seeking}
treat_dat_byID %>%
  freq(n)

```

By sample
```{r check number of overall treatment seeking by sample}
treat_dat_byIDSamp %>%
  group_by(Sample) %>%
  freq(n)
```

### Count of the number of different sources from which treatment was sought, by treatment type, wave

Supported
```{r num sources from which treatment sought supported}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeSought.Supported.total)

```
By sample
```{r num sources from which treatment sought supported by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeSought.Supported.total)

```


Self guided
```{r num sources from which treatment sought self guided}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeSought.SelfGuided.total)

```
By sample
```{r num sources from which treatment sought self guided by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeSought.SelfGuided.total)

```

### Frequency of treatment receipt by wave (any instances of treatment, not total instances)
Receiving ANY instances of this type of treatment (i.e., if they sought and received supported help from 3 sources in a  wave, it will just register once)

Supported
```{r treatment receipt by wave any}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.Supported.Any)

```
By sample
```{r treatment receipt by wave any by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeReceived.Supported.Any)

```


Supported
```{r treatment receipt by wave self guided any}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.SelfGuide.Any)
```
By sample
```{r treatment receipt by wave self guided any by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeReceived.SelfGuide.Any)
```

### Frequency of treatment receipt by wave (total)
HOW MANY instances of treatment were received

Supported
```{r treatment receipt by wave supported all}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.Supported.total)
```
By sample
```{r treatment receipt by wave supported all by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeReceived.Supported.total)
```

**Self guided**
```{r treatment receipt by wave self guided all}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.SelfGuided.total)
```

By sample
```{r treatment receipt by wave self guided all by sample}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.SelfGuided.total)
```


### Count of the number of different sources from which treatment was RECEIVED, by treatment type, wave

**Supported**
```{r num sources from which treatment received supported}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.Supported.total)

```
By sample
```{r num sources from which treatment received supported by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeReceived.Supported.total)

```


**Self guided**
```{r num sources from which treatment received self guided}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.SelfGuided.total)

```

By sample
```{r num sources from which treatment received self guided by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(TypeReceived.SelfGuided.total)

```

### Frequency of systemic / client reasons for non-receipt by wave and treatment type

Barriers to receiving treatment by wave.

This section highlights the frequency of encountering AT LEAST ONE type of each barrier per person per barrier type per wave.

Does not capture anyone more than once per category. i.e. someone who encountered 3 barriers, 1 of which was sytemic, one was client level and one was other wit appear once for each category. A person who experienced 3 systemic barriers will only be counted once (under systemic) 

#### For supported options**
**Systemic**
```{r check barriers by wave supported systemic}
treat_dat %>%
  group_by(wave) %>%
  freq(PreventHelp_Supported.Systemic)
```
By sample
```{r check barriers by wave supported systemic by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(PreventHelp_Supported.Systemic)
```

**Client-level**
```{r check barriers by wave supported client level}
treat_dat %>%
  group_by(wave) %>%
  freq(PreventHelp_Supported.Client)
```
By sample
```{r check barriers by wave supported client by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(PreventHelp_Supported.Client)
```

**Other**
```{r check barriers by wave supported otherl}
treat_dat %>%
  group_by(wave) %>%
  freq(PreventHelp_Supported.Other)
```
By sample
```{r check barriers by wave supported other by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(PreventHelp_Supported.Other)
```

#### For self guided options**
**Systemic**
```{r check barriers by wave SelfGuided systemic}
treat_dat %>%
  group_by(wave) %>%
  freq(PreventHelp_SelfGuided.Systemic)
```
By sample
```{r check barriers by wave SelfGuided systemic by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(PreventHelp_SelfGuided.Systemic)
```

**Client-level**
```{r check barriers by wave SelfGuided client level}
treat_dat %>%
  group_by(wave) %>%
  freq(PreventHelp_SelfGuided.Client)
```
By sample
```{r check barriers by wave SelfGuided client by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(PreventHelp_SelfGuided.Client)
```

**Other**
```{r check barriers by wave SelfGuided otherl}
treat_dat %>%
  group_by(wave) %>%
  freq(PreventHelp_SelfGuided.Other)
```
By sample
```{r check barriers by wave SelfGuided other by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(PreventHelp_SelfGuided.Other)
```

### Barriers by agency by wave
#### Supported

***Emergency mental health team***
```{r barriers by agency em mh}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_emergency_mh)

```
By sample
```{r barriers by agency em mh by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_emergency_mh)

```

***Existing mental health team***
```{r barriers by agency existing mh}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_existing_mh_team)

```
By sample
```{r barriers by agency existing mh by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_existing_mh_team)

```

***Online talk therapy***
```{r barriers by agency online talk}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_online_talk_therapy)

```
By sample
```{r barriers by agency online talk by sample }

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_online_talk_therapy)

```

***GP***
```{r barriers by agency GP}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_gp)

```
By sample
```{r barriers by agency gp by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_gp)

```

***NHS 111***
```{r barriers by agency nhs 111}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_nhs_111)

```
By sample
```{r barriers by agency nhs 111 by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_nhs_111)

```

***Non NHS phone***
```{r barriers by agency phone}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_nonnhs_phone)

```
By sample
```{r barriers by agencyphone by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_nonnhs_phone)

```

#### Self guided

***Government website***
```{r barriers by agency gov site}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_gov_website)

```
By sample
```{r barriers by agency gove site by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_gov_website)

```

***Non-government website***
```{r barriers by agency non gov site}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_nongov_website)

```
By sample
```{r barriers by agency non gov site by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_nongov_website)

```

***Online self-therapy***
```{r barriers by agency online self therapy}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_online_self_therapy)

```
By sample
```{r barriers by agency online self therapy by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_online_self_therapy)

```

***Structured therapeutic activity***
```{r barriers by agency structured therapeutic activity}

treat_dat %>%
  group_by(wave) %>%
  freq(preventhelp_struc_therapy)

```
By sample
```{r barriers by agency structured therapeutic activity by sample}

treat_dat %>%
  group_by(wave,Sample) %>%
  freq(preventhelp_struc_therapy)

```

### Frequency of different levels of helpfulness by treatment type (supported/client led) by wave

**For supported options**
```{r check helpfulness by wave supported}
treat_dat %>%
  group_by(wave) %>%
  freq(Helpfulness_Supported)
```
By sample
```{r check helpfulness by wave supported by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(Helpfulness_Supported)
```

**For  client led options**
```{r check helpfulness by wave client led}
treat_dat %>%
  group_by(wave) %>%
  freq(Helpfulness_SelfGuided)
```
By sample
```{r check helpfulness by wave client led by sample}
treat_dat %>%
  group_by(wave,Sample) %>%
  freq(Helpfulness_SelfGuided)
```

### Frequency of reasons for NOT seeking help

overall
```{r check }

for (i in grep("reasonNo", names(treat_dat)))
  print(freq(treat_dat[i]))


```

## Gender stratification for barriers

Add gender to treatment data 

```{r add gender to treat datgender}
treat_dat <- full_join(treat_dat,demgen)
```


### Treatment seeking rates by Gender


```{r treatment seeking freq by wave gender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(soughthelp_for_self)

```
By sample

```{r treatment seeking freq by wave by sample gender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(soughthelp_for_self)

```

### Reasons by gender


***Emergency mental health team***
```{r barriers by agency em mh gendergender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_emergency_mh)

```
By sample
```{r barriers by agency em mh by samplegender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_emergency_mh)

```

***Existing mental health team***
```{r barriers by agency existing mh gendergender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_existing_mh_team)

```
By sample
```{r barriers by agency existing mh by samplegender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_existing_mh_team)

```

***Online talk therapy***
```{r barriers by agency online talk gendergender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_online_talk_therapy)

```
By sample
```{r barriers by agency online talk by sample gender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_online_talk_therapy)

```

***GP***
```{r barriers by agency GP gendergender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_gp)

```
By sample
```{r barriers by agency gp by samplegender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_gp)

```

***NHS 111***
```{r barriers by agency nhs 111 gendergender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_nhs_111)

```
By sample
```{r barriers by agency nhs 111 by sample gendergender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_nhs_111)

```

***Non NHS phone***
```{r barriers by agency phone gendergender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_nonnhs_phone)

```
By sample
```{r barriers by agencyphone by samplegender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_nonnhs_phone)

```

#### Self guided

***Government website***
```{r barriers by agency gov sitegender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_gov_website)

```
By sample
```{r barriers by agency gove site by samplegender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_gov_website)

```

***Non-government website***
```{r barriers by agency non gov sitegender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_nongov_website)

```
By sample
```{r barriers by agency non gov site by samplegender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_nongov_website)

```

***Online self-therapy***
```{r barriers by agency online self therapygender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_online_self_therapy)

```
By sample
```{r barriers by agency online self therapy by samplegender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_online_self_therapy)

```

***Structured therapeutic activity***
```{r barriers by agency structured therapeutic activitygender}

treat_dat %>%
  group_by(wave,Gender) %>%
  freq(preventhelp_struc_therapy)

```
By sample
```{r barriers by agency structured therapeutic activity by samplegender}

treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(preventhelp_struc_therapy)

```

### Why not seek treatment by gender

```{r no treat seek by gen feel fine}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_feel_fine)

```

```{r no treat seek by gen feel better}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_I_feel_better)

```

```{r no treat seek by dont feel bad}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_I_dont_think_I_feel_bad_enough)

```

```{r no treat seek want it dont think its there}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_I_want_help_dont_think_its_available)

```

```{r no treat seek past bad experiences}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_Bad_experiences_in_past)

```

```{r no treat seek want it havent}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_I_want_to_but_havent)

```


```{r no treat seek too busy}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_Too_busy)

```

```{r no treat seek didnt know}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_I_didnt_know_where_to_find)

```

```{r no treat seek reasonNohelp_other}

treat_dat %>%
  group_by(Gender) %>%
  freq(reasonNohelp_other)

```


### Frequency of different levels of helpfulness by treatment type (supported/client led) by wave by gender

**For supported options**
```{r check helpfulness by wave supported Gender}
treat_dat %>%
  group_by(wave,Gender) %>%
  freq(Helpfulness_Supported)
```
By sample
```{r check helpfulness by wave supported by sample Gender}
treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(Helpfulness_Supported)
```

**For  client led options**
```{r check helpfulness by wave client led Gender}
treat_dat %>%
  group_by(wave,Gender) %>%
  freq(Helpfulness_SelfGuided)
```
By sample
```{r check helpfulness by wave client led by sample Gender}
treat_dat %>%
  group_by(wave,Sample,Gender) %>%
  freq(Helpfulness_SelfGuided)
```

## Geographic

Project postcode data onto map of the UK. Use downloaded long/lat data mapped to postcodes from [this site](https://www.freemaptools.com/download-uk-postcode-lat-lng.htm) and city names from [here](https://www.doogal.co.uk/UKPostcodes.php).

### Create clean, labelled and flat outcode dataset

```{r process downloaded geographic data}
setwd(wd)
source("./scripts/Create_labelled_outcode_dataset.R")
head(postcode_df_area)
```

### Create counts of treatment seeking and barriers by region

#### read in map libraries

```{r read in map libs}
if(!require(maps)){
  install.packages("maps")
  library(maps)
}
# get Uk from maps

UK <- map_data("world") %>% filter(region=="UK")


if(!require(mapproj)){
  install.packages("mapproj")
  library(mapproj)
}

```


```{r process and count treatment by area}
 setwd(wd)
 source("./scripts/RAMP_postcode_cleaning.R")

```


### Merge sample data to downloaded UK data

```{r merge national and RAMP data}
# 
postcode_full_seek <- left_join(postcode_seek,postcode_df_area,by="Outcode")
postcode_full <- left_join(postcode_full_seek,postcode_receive,by="Outcode")
# 
# # drop rows with no ID data as this indicates they did not exist in the downloaded Uk reference data
 postcode_full<- postcode_full[(!is.na(postcode_full$id) == T),]


```

### create counts by county and district

```{r county count dataset, eval=FALSE}
 setwd(wd)
 source("./scripts/Count_treatment_by_County.R")

```


check county data
```{r check head and count looks fine county, eval=FALSE}
head(postcode_full_County)

```

check district data
```{r check head and count looks fine district, eval=FALSE}
head(postcode_full_District)

```

## test building a UK map with districts plotted

```{r map district project test, eval=FALSE}

bb <- c(10,50,100,500,1000,5000,10000,15000)

maptest <- 
 postcode_full_County %>%
 arrange(longitude) %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), 
                 fill="grey", alpha=1) +
  geom_polygon( aes(x=longitude, y = latitude, group = County), 
                 fill="black", alpha=1)  +
  theme_void() + 
  coord_map() + 
  theme(legend.position="right") 

```

## Seeking attempts by total responses maps

### Treatment seeking by county (no labels)
Size of the circles = total number of responses
Colour of circles = percent of responses that indicated treatment seeking
```{r map for seeking by county colour no label,warning=FALSE, eval=FALSE}

bb <- c(10,50,100,500,1000,5000,10000,15000)

mapcolour <- 
 postcode_full_County %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), 
                 fill="grey", alpha=1) +
    geom_point( aes(x=longitude, y=latitude, 
                    size=TotalResponsesCounty, 
                    color=CountyGapProportionTotalSeek), 
                alpha=1) +
    scale_size_continuous(range = c(1,30),
                          breaks = bb,
                          limits = c(1,15000)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolour

```
### Treatment seeking by district (no labels)

Size of the circles = total number of responses
Colour of circles = percent of responses that indicated treatment seeking
```{r map for seeking by district colour no label,warning=FALSE, eval=FALSE}

bb <- c(10,100,500,1000,2000,3000)

mapcolour <- 
 postcode_full_District %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), 
                 fill="grey", alpha=1) +
    geom_point( aes(x=longitude, y=latitude, 
                    size=TotalResponsesDistrict, 
                    color=SeekProportionTotalDistrict), 
                alpha=1) +
    scale_size_continuous(range = c(1,20),
                          breaks = bb,
                          limits = c(1,3000)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolour

```


### Labelled the 5 counties ith greatest proporton seeking by total responses

#### county
```{r map for seeking by county colour labelled,warning=FALSE, eval=FALSE}
bb <- c(10,50,100,500,1000,5000,10000,15000)

mapcolourlabel <- 
 postcode_full_County %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill="grey", alpha=0.5) +
  
    geom_point( aes(x=longitude, y=latitude, size=TotalResponsesCounty, color=CountyGapProportionTotalSeek), alpha=0.8) +
  
    geom_text_repel( data=postcode_full_County %>% 
                       arrange(CountyGapProportionTotalSeek) %>% 
                       tail(5), 
                     aes(x=longitude, y=latitude, label=County), 
                     size=4) +
  
   geom_point( data=postcode_full_County %>% 
                 arrange(CountyGapProportionTotalSeek) %>% 
                 tail(5), 
               aes(x=longitude, y=latitude), 
               color="#78D9C5", 
               size=2) +
  
    scale_size_continuous(range = c(1,40),
                          breaks = bb,
                          limits = c(1,15000)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolourlabel

```


#### district labelled with marker points for most percentage seek attempts by responses
orange markers for top 5 biggest gap, with labels

```{r map for seeking by district colour labelled markers,warning=FALSE, eval=FALSE}

bb <- c(10,100,500,1000,2000,3000)

mapcolourlabel <- 
 postcode_full_District %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill="grey", alpha=0.5) +
  
    geom_point( aes(x=longitude, y=latitude, size=TotalResponsesDistrict, color=SeekProportionTotalDistrict), alpha=0.8) +
  
    geom_text_repel( data=postcode_full_District %>% 
                       arrange(SeekProportionTotalDistrict) %>% 
                       tail(10), 
                     aes(x=longitude, y=latitude, label=District), 
                     size=4) +
  
   geom_point( data=postcode_full_District %>% 
                 arrange(SeekProportionTotalDistrict) %>% 
                 tail(10), 
               aes(x=longitude, y=latitude), 
               color="#78D9C5", 
               size=2) +
  
    scale_size_continuous(range = c(1,20),
                          breaks = bb,
                          limits = c(1,3000)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolourlabel

```

#### district labelled with marker points (no labels)
orange markers for top 5 biggest gap, WITHOUT labels

```{r map for seeking by district colour markers no labels,warning=FALSE, eval=FALSE}

bb <- c(10,100,500,1000,2000,3000)

mapcolourlabel <- 
 postcode_full_District %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill="grey", alpha=0.5) +
  
    geom_point( aes(x=longitude, y=latitude, size=TotalResponsesDistrict, color=SeekProportionTotalDistrict), alpha=0.8) +
  
   geom_point( data=postcode_full_District %>% 
                 arrange(SeekProportionTotalDistrict) %>% 
                 tail(10), 
               aes(x=longitude, y=latitude), 
               color="orange", 
               size=2) +
  
    scale_size_continuous(range = c(1,20),
                          breaks = bb,
                          limits = c(1,3000)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 

#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolourlabel

```

#### district - only top ten gap treatment seeking attemps

```{r map for seeking by district colour labelled top ten only,warning=FALSE, eval=FALSE}

bb <- c(100,300,500)

mapcolourlabel <- 
 postcode_full_District %>%
  arrange(SeekProportionTotalDistrict) %>% 
  tail(10) %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill="grey", alpha=0.5) +
  
    geom_point( aes(x=longitude, y=latitude, size=TotalResponsesDistrict, color=SeekProportionTotalDistrict), alpha=0.8) +
  
    geom_text_repel( data=postcode_full_District %>% 
                       arrange(SeekProportionTotalDistrict) %>% 
                       tail(10), 
                     aes(x=longitude, y=latitude, label=District), 
                     size=4) +
  
  
  
    scale_size_continuous(range = c(1,20),
                          breaks = bb,
                          limits = c(1,600)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolourlabel


```


## Treatment gaps by total treatment seeking

### Treatment gap by county (no labels)
Size of the circles = total number of seeking attempts
Colour of circles = percent of times treatment was not received when it was sought
```{r map for gap by county colour no label,warning=FALSE, eval=FALSE}

bb <- c(10,100,500,1000,2000,3000)

mapcolour <- 
 postcode_full_County %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), 
                 fill="grey", alpha=1) +
    geom_point( aes(x=longitude, y=latitude, 
                    size=SeekAttemptsCountyTotal, 
                    color=CountyGapProportionTotalSeek), 
                alpha=1) +
    scale_size_continuous(range = c(1,40),
                          breaks = bb,
                          limits = c(1,2500)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolour

```
### Treatment gap by district (no labels)

Size of the circles = total number of responses
Colour of circles = percent of responses that indicated treatment gap
```{r map for gap by district colour no label,warning=FALSE, eval=FALSE}

bb <- c(10,50,100,300,500)

mapcolour <- 
 postcode_full_District %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), 
                 fill="grey", alpha=1) +
    geom_point( aes(x=longitude, y=latitude, 
                    size=SeekAttemptsDistrictTotal, 
                    color=DistrictGapProportionTotalSeek), 
                alpha=1) +
    scale_size_continuous(range = c(1,12),
                          breaks = bb,
                          limits = c(1,500)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolour

```


### Labelled the 5 counties ith greatest proporton gap by total responses

#### county
```{r map for gap by county colour labelled,warning=FALSE, eval=FALSE}
bb <- c(10,50,100,300,500)

mapcolourlabel <- 
 postcode_full_County %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill="grey", alpha=0.5) +
  
    geom_point( aes(x=longitude, y=latitude, size=SeekAttemptsCountyTotal, color=CountyGapProportionTotalSeek), alpha=0.8) +
  
    geom_text_repel( data=postcode_full_County %>% 
                       arrange(CountyGapProportionTotalSeek) %>% 
                       tail(5), 
                     aes(x=longitude, y=latitude, label=County), 
                     size=4) +
  
   geom_point( data=postcode_full_County %>% 
                 arrange(CountyGapProportionTotalSeek) %>% 
                 tail(5), 
               aes(x=longitude, y=latitude), 
               color="#78D9C5", 
               size=2) +
  
    scale_size_continuous(range = c(1,40),
                          breaks = bb,
                          limits = c(1,2500)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolourlabel

```


#### district labelled with marker points for most percentage seek attempts by responses
orange markers for top 5 biggest gap, with labels

```{r map for gap by district colour labelled markers,warning=FALSE, eval=FALSE}

bb <- c(10,50,100,300,500)

mapcolourlabel <- 
 postcode_full_District %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill="grey", alpha=0.5) +
  
    geom_point( aes(x=longitude, y=latitude, size=SeekAttemptsDistrictTotal, color=DistrictGapProportionTotalSeek), alpha=0.8) +
  
    geom_text_repel( data=postcode_full_District %>% 
                       arrange(DistrictGapProportionTotalSeek) %>% 
                       tail(10), 
                     aes(x=longitude, y=latitude, label=District), 
                     size=4) +
  
   geom_point( data=postcode_full_District %>% 
                 arrange(DistrictGapProportionTotalSeek) %>% 
                 tail(10), 
               aes(x=longitude, y=latitude), 
               color="#78D9C5", 
               size=2) +
  
    scale_size_continuous(range = c(1,12),
                          breaks = bb,
                          limits = c(1,500)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolourlabel

```

#### district labelled with marker points (no labels)
orange markers for top 5 biggest gap, WITHOUT labels

```{r map for gap by district colour markers no labels,warning=FALSE, eval=FALSE}

bb <- c(10,50,100,300,500)

mapcolourlabel <- 
 postcode_full_District %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill="grey", alpha=0.5) +
  
    geom_point( aes(x=longitude, y=latitude, size=SeekAttemptsDistrictTotal, color=DistrictGapProportionTotalSeek), alpha=0.8) +
  
   geom_point( data=postcode_full_District %>% 
                 arrange(DistrictGapProportionTotalSeek) %>% 
                 tail(10), 
               aes(x=longitude, y=latitude), 
               color="orange", 
               size=2) +
  
    scale_size_continuous(range = c(1,12),
                          breaks = bb,
                          limits = c(1,500)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 

#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolourlabel

```

#### district - only top ten gap treatment gap attemps

Filtered to districts where fewer than 5 seek attempts in the district
```{r map for gap by district colour labelled top ten only,warning=FALSE, eval=FALSE}

bb <- c(10,50,100,150)

mapcolourlabel <- 
 postcode_full_District %>%
  filter(SeekAttemptsDistrictTotal > 5) %>%
  arrange(DistrictGapProportionTotalSeek) %>% 
  tail(10) %>%
  
 ggplot() +
    geom_polygon(data = UK, aes(x=long, y = lat, group = group), fill="grey", alpha=0.5) +
  
    geom_point( aes(x=longitude, y=latitude, size=SeekAttemptsDistrictTotal, color=DistrictGapProportionTotalSeek), alpha=0.8) +
  
    geom_text_repel( data=postcode_full_District %>% 
                       filter(SeekAttemptsDistrictTotal > 5) %>%
                       arrange(DistrictGapProportionTotalSeek) %>% 
                       tail(10), 
                     aes(x=longitude, y=latitude, label=District), 
                     size=4) +
  
  
  
    scale_size_continuous(range = c(1,30),
                          breaks = bb,
                          limits = c(1,600)) +

  scale_color_viridis(trans="log10",alpha = 1,option = "D") +
  
  theme_void() + 
  ylim(50,59) + 
  coord_map() + 
  theme(legend.position="right") 


#ggsave(paste0(wdirect,"RAMPparticipantMap_colour.png"),mapcolour,dpi=300)

mapcolourlabel


```


## Mapping alongside indices of multiple deprivation
used most recent in all cases (2019 for England and Wales, 2020 for Scotland, 2017 for Northern Ireland)

### Indices of multiple deprivation were downloaded from:

[England](https://opendatacommunities.org/resource?uri=http%3A%2F%2Fopendatacommunities.org%2Fdata%2Fsocietal-wellbeing%2Fimd2019%2Findices)
[Ireland](https://www.nisra.gov.uk/publications/nimdm17-soa-level-results)
[Scotland](https://www.gov.scot/publications/scottish-index-of-multiple-deprivation-2020v2-ranks/)
*note: using the revised 2020 version for Scotland. See note on Website. Description of indicators is available on sheet 2 of excel downloaded from this link*
[Wales](https://statswales.gov.wales/Catalogue/Community-Safety-and-Social-Inclusion/Welsh-Index-of-Multiple-Deprivation/WIMD-2019/localauthorityanalysis)

### Shapefiles for mapping districts were downloaded from:
[GB (excluding Ireland)](https://www.ordnancesurvey.co.uk/business-government/products/boundaryline)
[IRE](https://www.opendatani.gov.uk/dataset/osni-open-data-largescale-boundaries-ni-outline1)

Projection of shapefiles converted to the Ordnance Survey Great Britain 1936 system (OSGB36 - EPSG code: 27700) to project into common space

### Notes

Using MDI rank for the time being - so ranks within each boundary will be comparable

## clean IMD data

```{r  clean indices of multiple deprivation data, eval=FALSE}

setwd(wd)
source("./scripts/clean_MDI_data.R")

```

## create shapefiles for maps with polygons for plotting district boundaries

```{r shapefile creation, eval=FALSE}

setwd(wd)
source("./scripts/choropelth_map_districts.R")

```


## combine the IMD and shapefiles

```{r combine IMD and shapes, eval=FALSE}
setwd(wd)
source("./scripts/merge_mapShapefiles_and_IMD_data.R")
```


## Plot IMD on map

```{r IMD map plot, eval=FALSE}

## draw plot using ggplot and geom_sf

pl <- UK_ll %>% 
  left_join(IMD_only) %>%
  ggplot() + 
  geom_sf(lwd = .1,color = 'black', aes(fill = Rank)) + 
  theme_void() +
  lims(fill = c(10,4000)) + 
  scale_fill_viridis_c(option = 'plasma') + 
  labs(title = "Title of the plot\nwith a sub title", 
       fill = 'No. responses:') + 
  theme(legend.position = 'left') +
  theme(title = element_text(size = 12), 
        legend.title = element_text(size = 8))

pl

```
### only IMD

### with treatmetn seeking

### with treatment gap

## Analytic decision notes

### Including cohort as a covariate

This would likely be a collider (sx severity is going to be associated with both cohort and treatment seeking)

#### NOTE TO SELF:: fix any treatment barrier stuff
#### make sure the counts are referring to the right thing!


