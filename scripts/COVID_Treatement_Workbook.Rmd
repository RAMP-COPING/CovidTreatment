---
title: "RAMP/COPING treatment paper core notebook"

author: "K L Purves"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output:
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: false
    number_sections: false
    highlight: monochrome
    theme: cerulean
code_folding: show

html_notebook:
  theme: cerulean
toc: yes
---

This workbook runs code and shows results for the manuscript ***Access and uptake of mental health services during the COVID-19 pandemic: rates, barriers and usefulness***. 

# Project description

#### Research questions

1. What are the rates for treatment seeking for MH concerns at each time point (wave)
- rates over time

2. 

#### Details, discussion and questions

How do we show change over time in treatment seeking and receipt over time?
- are services overwhelmed?

#### Predictors

We select predictors that predict worse outcomes for common mental health problems in this sample [see GitHub for relevant paper here](https://github.com/klpurves/PANCHANGE_analysis/tree/forest_plots)


#### submission

Will submit to Psychological Medicine in first instance

#### variables that need creating

- did you seek treatment at any time

#### Variable categorisation

**treatment type:**
supported (requires contact) or self guided ()

Categorisation makes sense for resource allocation etc.

**reasons for seeking**
new or existing
crisis as a third (number dependent)

**barriers**
Systemic and client level

#### People who have helped along the way
Henry 
Laura
Molly

#### Figures

1. COVID figures, lockdown dates, histogram/density 
2. Bar plot 
3. Map of the UK showing rates of treatment seeking and receipt per area (prop sought treatment == size, proportion received == colour) probably district or rgion level?
4. Forest plots

** prevention figure: bars for each barrier type, coloured by whether systemic or client led

# set up 

Clear global environment
```{r Clear global environment}
remove(list = ls())
```

#### Call in set up scripts

```{r source files}
#source data directory: data_path
source("/Users/kirstin/Dropbox/SGDP/RAMP/Projects/Treatment/file_paths.R")
setwd(wd)
source("./scripts/palettes.R")
source("./scripts/libraries.R")

```


```{r Setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      comment=NA,
                      prompt=FALSE,
                      cache=FALSE,
                      root.dir=wd)

knitr::opts_chunk$set(fig.path="figures/")



options(bitmapType = 'quartz') # to render fonts better
```

Retrieve the current date to use it for file endings to not overwrite files when one exports files
```{r Recent date}
date = Sys.Date()
```

#### R functions

```{r call in function library functions}

# source all functions in the function library folder
files.sources = paste0("../FunctionLib/",list.files("../FunctionLib"))
sapply(files.sources, source)

```

# Data wrangling

#### Data import
RAMP
```{r read in data ramp}
treatRAMP <- readRDS(file = paste0(data_path, "/ramp_followupb/treatment_ramp_followupb.rds"))
demRAMP <- readRDS(file = paste0(data_path, "/ramp/dem_ramp.RDS"))

```

COPING
Note, external data refrence is a hash-id for coping. So it is consistent across aprticipants and matches, but is not linkable to GLAD ID
```{r read in data coping}
treatCOPE <- readRDS(file = paste0(cope_path, "/coping_followupa_ongoing/treatment_coping_followupa_ongoing.rds"))
demCOPE.glad <- readRDS(file = paste0(data_path, "/coping_glad/dem_coping_glad.RDS"))
demCOPE.edgi <- readRDS(file = paste0(data_path, "/coping_edgi/dem_coping_edgi.RDS"))
demCOPE.nbr <- readRDS(file = paste0(data_path, "/coping_nbr/dem_coping_nbr.RDS"))

```

#### Create a wave columns in treatment data
Base this on dates of the follow ups drawn from qualtrics.

RAMP
5 waves

1 - May 2020
2 - June 2020
3 - July 2020 (start date actually the last day of June)
4 - September 2020
5 - November 2020

```{r identify wave dates ramp}
setwd(wd)
source("./scripts/RAMPwaves.R")
```

COPING
```{r identify wave dates coping}
setwd(wd)
source("./scripts/COPINGwaves.R")
```
#### drop data before data collection started

Drop Any data collected earleir than June (our first instance of the questionnaire)

```{r drop May dat}

treatRAMP <- treatRAMP %>%
  filter(startDate > as.POSIXct("2020-06-01"))

```

#### select only relevant demographics

```{r demographic select list}
keepcols.cope <- c("externalDataReference","dem.which_gender_do_you_identify_with")
cols.cope <- c("LoginID","Gender")
keepcols.nbr <- c("subjectid")
cols.nbr <- c("LoginID")
keepcols.ramp <- c("externalDataReference","dem2.how_old_are_you","dem2.which_gender_do_you_identify_with")
cols.ramp <- c("LoginID","Age","Gender")
```


```{r demographic select}
dem.cope.glad <- demCOPE.glad[names(demCOPE.glad) %in% keepcols.cope]
dem.cope.edgi <- demCOPE.edgi[names(demCOPE.edgi) %in% keepcols.cope]
dem.cope.nbr <- demCOPE.nbr[names(demCOPE.nbr) %in% keepcols.nbr]
dem.ramp <- demRAMP[names(demRAMP) %in% keepcols.ramp]

names(dem.cope.glad) <- cols.cope
names(dem.cope.edgi) <- cols.cope
names(dem.cope.nbr) <- cols.nbr
names(dem.ramp) <- cols.ramp
```
#### add sample columns 

```{r add sample col}

dem.cope.glad$Sample <-  "COPING"
dem.cope.edgi$Sample <- "COPING"
dem.cope.nbr$Sample <- "COPING"
dem.ramp$Sample <- "RAMP"

treatRAMP$Sample <- "RAMP"
treatCOPE$Sample <- "COPING"

```

## SPACE FOR PREDICTOR CLEANING

Will need to find and add predictor variables. Will add this here.

#### merge demographcis

Waiting till I can get age into GLAD & EDGI

```{r demographics merge}

dem <- merge(dem.cope.glad,dem.cope.edgi)
dem <- merge(dem,dem.cope.nbr)
dem <- merge(dem,dem.ramp)

```

#### Rename the treatment variables and drop irrelevant ones

used the [data dictionary](https://docs.google.com/spreadsheets/d/1Vp028XLxbcXeOdjeuI-3y-kVenKWDR4hW9iJ1tHpttI/edit#gid=1527211037) to identify the relevant items and rename them

```{r rename COPE & RAMP datasets and select variables}
setwd(wd)
source("./scripts/renameRAMPtreatment.R")

treatRAMP.fin <- treatRAMP.renamed[names(treatRAMP.renamed) %in% treatnames]
treatCOPE.fin <- treatCOPE.renamed[names(treatCOPE.renamed) %in% treatnames]

```
#### merge RAMP and COPING treatment data

Use rbind to add COPING to RAMP

```{r merge coping and ramp treatment data}

treat_dat <- rbind(treatRAMP.fin,treatCOPE.fin)
  
```

#### order wave variable

```{r reorder wave factor}

treat_dat$wave <- factor(treat_dat$wave,
                         levels = c("May 2020","June 2020", "July 2020","August 2020","September 2020","October 2020","November 2020","December 2020","January 2021"))

```

#### Drop accidental duplicate IDs

these are IDS that were allocated twice by qualtrics. Technical errors. Will drop all instances
```{r id  duplicates}

DupIDdat <- treat_dat %>%
  pivot_wider(id_cols = ID,
              names_from = wave,
              values_from = soughthelp_for_self,
              values_fn = length)

dupids <- DupIDdat$ID[(DupIDdat$`June 2020` > 1 | DupIDdat$`July 2020` > 1 |
                         DupIDdat$`August 2020` > 1 | DupIDdat$`September 2020` > 1 |
                         DupIDdat$`October 2020` > 1 | DupIDdat$`November 2020` > 1 |
                         DupIDdat$`December 2020` > 1 | DupIDdat$`January 2021` > 1)]

dupids <- unique(dupids)

```

Now drop from our treatment data

```{r drop dups from treatment}
treat_dat <- treat_dat[(treat_dat$ID %!in% dupids),]
```

#### make prefer not say NA for purposes of this analyses

```{r make -77 in treatment seeking NA}

treat_dat$soughthelp_for_self <- ifelse(treat_dat$soughthelp_for_self == -77,NA,treat_dat$soughthelp_for_self)

```

#### Create summary variables for treatment
Grouping variables to make sensible categories for comparing different aspects of treatment seeking


##### Sought help for new or pre-existing MH disorder 

Categorise reasons for help seeking into whether it was for a pre-existing, newly emerging MH disorder or a crisis

```{r dummy reason for help seek variable}

treat_dat <- treat_dat %>%
  mutate(ReasonSeek = case_when(reasonhelp_new_mh == 1 ~ "Newly emerging symptoms",
                                reasonhelp_new_med == 1 ~ "Newly emerging symptoms",
                                reasonhelp_cont_mh == 1 ~ "Existing mental health disorder",
                                reasonhelp_worsen_mh == 1 ~ "Existing mental health disorder",
                                reasonhelp_repeat_prescription == 1 ~ "Existing mental health disorder",
                                reasonhelp_change_med == 1 ~ "Existing mental health disorder",
                                reasonhelp_alt_support == 1 ~ "Existing mental health disorder",
                                reasonhelp_mh_crisis == 1 ~ "Mental health crisis" ))

```


##### Type of treatment (supported / self guided)

Categorise places where treatment was sought into supported or self-guided


make Prefer not to say (-77) NA

```{r na for PNS treatment type sought}
treat_dat[grep("wherehelp",names(treat_dat))] <-apply(treat_dat[grep("wherehelp",names(treat_dat))],2,function(x) ifelse(x == -77,NA, x))
```

create a variable that will say if they sought supported or self guided for each support instance
```{r dummy type of treatment sought}

treat_dat <- treat_dat %>%
  mutate(TypeSought = case_when(wherehelp_sought_emergency_mh == 1 ~ "Supported",
                               wherehelp_sought_existing_mh_team == 1 ~ "Supported",
                                wherehelp_sought_online_talk_therapy == 1 ~ "Supported",
                                wherehelp_sought_gp == 1 ~ "Supported",
                                wherehelp_received_nonnhs_phone == 1 ~ "Supported",
                                wherehelp_sought_nhs_111 == 1 ~ "Supported",
                                wherehelp_sought_gov_website == 1 ~ "Self-guided",
                                wherehelp_received_selfguide_online == 1 ~ "Self-guided",
                                wherehelp_sought_nongov_website == 1 ~ "Self-guided",
                                wherehelp_sought_struc_therapy == 1 ~ "Self-guided"))
```

creat variable counting number of self guided or supported treatment types sought per wave per person

```{r type sought counts}

supportcols <- c("wherehelp_sought_emergency_mh","wherehelp_sought_online_talk_therapy",
                 "wherehelp_sought_gp","wherehelp_sought_existing_mh_team",
                " wherehelp_received_nonnhs_phone","wherehelp_sought_nhs_111")

selfcols <- c("wherehelp_sought_gov_website","wherehelp_received_selfguide_online",
                 "wherehelp_sought_nongov_website","wherehelp_sought_struc_therapy")


treat_dat$TypeSought.Supported.total <- rowSums(treat_dat[names(treat_dat) %in% supportcols],na.rm = T)
treat_dat$TypeSought.SelfGuided.total <- rowSums(treat_dat[names(treat_dat) %in% selfcols],na.rm = T)

```

##### received treatment if sought 

identify if treatment was received when sought according to category
```{r dummy type of treatment received}

treat_dat <- treat_dat %>%
  mutate(TypeReceived.Supported.Any  = case_when(wherehelp_received_emergency_mh == 1 ~ "Received Supported",
                               wherehelp_received_existing_mh_team == 1 ~ "Received Supported",
                                wherehelp_received_online_talk_therapy == 1 ~ "Received Supported",
                                wherehelp_received_gp == 1 ~ "Received Supported",
                                wherehelp_received_nonnhs_phone == 1 ~ "Received Supported",
                                wherehelp_received_nhs_111 == 1 ~ "Received Supported", 
                               TRUE ~ "Did not receive supported treatment"),
         TypeReceived.SelfGuide.Any = case_when(
                                wherehelp_received_gov_website == 1 ~ "Received Self-guided",
                                wherehelp_received_selfguide_online == 1 ~ "Received Self-guided",
                                wherehelp_received_nongov_website == 1 ~ "Received Self-guided",
                                wherehelp_received_struc_therapy == 1 ~ "Received Self-guided",
                                TRUE ~ "Did not receive self-guided treatment")) %>%
  
  mutate(AnyReceived = case_when(TypeReceived.Supported.Any  == "Received Supported" ~ 1,
                                  TypeReceived.SelfGuide.Any  == "Received Self-guided" ~ 1,
                                 TRUE ~ 0))
```

##### number of agencies from which treatment was received, if sought


```{r type received counts}

supportcols <- c("wherehelp_received_emergency_mh","wherehelp_received_online_talk_therapy",
                 "wherehelp_received_gp","wherehelp_received_existing_mh_team",
                " wherehelp_received_nonnhs_phone","wherehelp_received_nhs_111")

selfcols <- c("wherehelp_received_gov_website","wherehelp_received_selfguide_online",
                 "wherehelp_received_nongov_website","wherehelp_received_struc_therapy")


treat_dat$TypeReceived.Supported.total <- rowSums(treat_dat[names(treat_dat) %in% supportcols],na.rm = T)
treat_dat$TypeReceived.SelfGuided.total <- rowSums(treat_dat[names(treat_dat) %in% selfcols],na.rm = T)

```

```{r treatment type counts sought}

treat_dat_typesought <- treat_dat %>%
  select(ID,TypeSought,wave) %>%
  group_by(ID) %>%
  mutate(check = str_count(TypeSought,"Supported"))
  
```

##### Sought treatment at any time (How many times, how many total responses)

Create a dataset and column that identifies how many times someone sought help, how many times they responded, and if they ever sought help

Making a new dataset where the count by ID is tracked
```{r treatment seek in any wave count}

treat_dat_byID <- treat_dat %>%
  group_by(ID) %>%
  tally(soughthelp_for_self)

```

```{r treatment seek in any wave}

treat_dat_byID$AnySeek <- ifelse(treat_dat_byID$n > 0,"Sought help at least once", "Never sought help")

```

##### Received help having sought it (include proportion of times help is received having sought it)
Check if anyone has not received help at all having sought it, check proportion of times help received having sought it, seperated into supported vs self-guided treatments
```{r received help having sought it}


```

##### Client level vs systemic barriers
identify if treatment was received when sought according to category

```{r run script to relabel and clean treatment hep and barrier factors}
setwd(wd)
## factorise and label barrier and helpfulness 
source("./scripts/relabel_barriers_help_factors.R")

```

Identify whether barriers are systemic or client-level
```{r dummy type of barriers}
## systemic
treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Could not get an appointment","Systemic",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Waiting list was too long","Systemic",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Was assessed and was unable to be offered support","Systemic",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Support option was unavailable when tried to access it","Systemic",x))

## client level
treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "None of the support options were relevant","Client-level",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Didn't feel well enough to engage","Client-level",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Was too busy to engage","Client-level",x))

treat_dat[grep("prevent",names(treat_dat))] <- apply(treat_dat[grep("prevent",names(treat_dat))], 2, function(x) 
  ifelse(x == "Felt better","Client-level",x))

```

#### group agencies for help prevention into client-led or supported
creates PreventHelp_Supported and PreventHelp_SelfGuided columns

```{r group barrier agencies into client led or supported}
setwd(wd)
source("./scripts/Barriers_column_creation.R")
```

### helpfulness

#### Relabel factors

```{r relabel helpfullness factors}

setwd(wd)
source("./scripts/Relabel_helpful_factors.R")

```

# Aim 1 analyses

## Descriptives

### Response rates per wave

```{r response rates per wave}

treat_dat %>%
  group_by(wave) %>%
  count()

```

### Frequency of treatment seeking per wave

```{r treatment seeking freq by wave}

treat_dat %>%
  group_by(wave) %>%
  freq(soughthelp_for_self)

```

### Frequency of treatment seeking overall
Number of people who sought treatment at any point during the pandemic
```{r check  overall treatment seeking}

treat_dat_byID %>%
  freq(AnySeek)

```

### Count table of treatment seeking across all waves
Number of times people sought treatment at any point during the pandemic
```{r check number of overall treatment seeking}
table(treat_dat_byID$n)
```

### Count of the number of different sources from which treatment was sought, by treatment type, wave

Supported
```{r num sources from which treatment sought supported}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeSought.Supported.total)

```


Self guided
```{r num sources from which treatment sought self guided}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeSought.SelfGuided.total)

```

### Frequency of treatment receipt by wave (any instances of treatment, not total instances)
Seeking ANY instances of this type of treatment (i.e., if they sought supported help from 3 sources ina  wave, it will just register once)

Supported
```{r treatment receipt by wave any}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.Supported.Any)

```


Supported
```{r treatment receipt by wave self guided any}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.SelfGuide.Any)

```

### Frequency of treatment receipt by wave (total)
HOW MANY instances of treatment were received

Supported
```{r treatment receipt by wave supported all}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.Supported.total)

```

Self guided
```{r treatment receipt by wave self guided all}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.SelfGuided.total)

```


### Count of the number of different sources from which treatment was RECEIVED, by treatment type, wave

Supported
```{r num sources from which treatment received supported}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.Supported.total)

```


Self guided
```{r num sources from which treatment received self guided}
treat_dat %>%
  group_by(wave) %>%
  freq(TypeReceived.SelfGuided.total)

```

### Frequency of systemic / client barriers by wave

Barriers to receiving treatment by wave.

For supported options
```{r check barriers by wave supported}
treat_dat %>%
  group_by(wave) %>%
  freq(PreventHelp_Supported)
```

For client led options
```{r check barriers by wave client led}
treat_dat %>%
  group_by(wave) %>%
  freq(PreventHelp_SelfGuided)
```

### Number of times sought treatment (relative to number of times responded)


### Frequency of reasons for seeking treatment (by wave)

```{r freq treatment seek reasons}

treat_dat %>%
  group_by(wave) %>%
  freq(ReasonSeek)

```


### Frequency of reasons for seeking treatment (by wave, by treatment seeking numbers)
Note: Some people may have sought help more than once for more than one reason

The people who have a reason, but also fall in the did not seek treatment for self column (0) will be people who sought help at at least one point and gave a reason for that, but obviously might not have done so at every point.

```{r freq treatment seek reasons crosstab sought help}
with(treat_dat, ctable(ReasonSeek,soughthelp_for_self))
```


## Analytic decision notes

### Including cohort as a covariate

This would likely be a collider (sx severity is going to be associated with both cohort and treatment seeking)

